#!/bin/bash

# rest-init - Initialize a new Go REST API project in the current directory

REPO_URL="https://github.com/mwdev22/rest-boilerplate.git"
TEMPLATE_DIR="/opt/rest-init"

TEMPLATE_TYPE="${1:-flat}"
if [[ "$TEMPLATE_TYPE" != "flat" && "$TEMPLATE_TYPE" != "standard" ]]; then
    echo "Usage: $(basename "$0") [flat|standard]"
    exit 1
fi

if [ ! -d "$TEMPLATE_DIR" ]; then
    sudo git clone "$REPO_URL" "$TEMPLATE_DIR"
else
    cd "$TEMPLATE_DIR" && sudo git pull --rebase && cd - >/dev/null
fi

if [ ! -d "$TEMPLATE_DIR/.git" ]; then
    echo "Error: $TEMPLATE_DIR is not a valid git repository."
    exit 1
fi

TEMPLATE_SUBDIR="$TEMPLATE_DIR/$TEMPLATE_TYPE"
if [ ! -d "$TEMPLATE_SUBDIR" ]; then
    echo "Error: Template type '$TEMPLATE_TYPE' not found in $TEMPLATE_DIR"
    exit 1
fi

if [ -e "./go.mod" ]; then
    read -p "A go.mod exists here. Continue and overwrite? [y/N] " ans
    [[ "$ans" =~ ^[Yy]$ ]] || exit 1
fi

rsync -av --exclude='.git' --exclude='rest-init' "$TEMPLATE_SUBDIR"/ ./ || {
    echo "Error: Failed to copy boilerplate template to current directory."
    exit 1
}

detected_module=""
if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    remote_url=$(git config --get remote.origin.url || true)
    if [ -n "$remote_url" ]; then
        if [[ "$remote_url" =~ ^git@([^:]+):(.+)\.git$ ]]; then
            host="${BASH_REMATCH[1]}"
            path="${BASH_REMATCH[2]}"
            detected_module="$host/$path"
        elif [[ "$remote_url" =~ ^https?://([^/]+)/(.*)(\.git)?$ ]]; then
            host="${BASH_REMATCH[1]}"
            path="${BASH_REMATCH[2]}"
            path="${path%%.git}"
            detected_module="$host/$path"
        fi
    fi
fi

MODULE_PATH=""
if [ -n "$detected_module" ]; then
    MODULE_PATH="$detected_module"
    echo "Detected git remote. Will use module path: $MODULE_PATH"
else
    read -p "Enter Go module path (e.g. github.com/you/your-repo). Leave empty to skip automatic update: " MODULE_PATH
fi

if [ -n "$MODULE_PATH" ]; then
    echo "Updating module path to: $MODULE_PATH"
    if [ -f go.mod ]; then
        sed -i.bak -E "s|^module .*|module $MODULE_PATH|" go.mod && rm -f go.mod.bak
    else
        printf "module %s\n\nrequire (\n)\n" "$MODULE_PATH" > go.mod
    fi

    old_base="github.com/mwdev22/rest-boilerplate"
    grep -R --line-number --exclude-dir=.git "$old_base" . >/dev/null 2>&1 && {
        files=$(grep -R --line-number --exclude-dir=.git "$old_base" . | cut -d: -f1 | sort -u)
        for f in $files; do
            sed -i.bak "s|$old_base|$MODULE_PATH|g" "$f" && rm -f "$f.bak"
        done
    }

    grep -R --line-number --exclude-dir=.git "mwdev22/rest-boilerplate" . >/dev/null 2>&1 && {
        files=$(grep -R --line-number --exclude-dir=.git "mwdev22/rest-boilerplate" . | cut -d: -f1 | sort -u)
        for f in $files; do
            sed -i.bak "s|mwdev22/rest-boilerplate|${MODULE_PATH#*/}|g" "$f" && rm -f "$f.bak"
        done
    }

    if command -v go >/dev/null 2>&1; then
        echo "Running 'go mod tidy' (best-effort). This may require network access."
        (go mod tidy) || echo "go mod tidy failed or skipped; you can run it manually later."
    fi
else
    echo "Skipping automatic go.mod/imports update. You can update module name manually in go.mod."
fi

echo "==>  ($TEMPLATE_TYPE) structure has been initialized in $(pwd)"
echo "    - verify 'go.mod' module name (updated automatically if a module path was detected or provided)"
echo "    - edit your .env as needed"
echo "    - run 'go mod tidy' if you didn't already"
